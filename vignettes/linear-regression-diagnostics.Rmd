---
title: "Linear regression diagnostics"
description: A tutorial on linear regression diagnostics using the regressinator.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Linear regression diagnostics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(regressinator)
library(ggplot2)
library(broom)
```

The basic linear regression model assumes that
$$
Y = \beta_0 + \beta_1 X_1 + \dots + \beta_p X_p + \epsilon,
$$
where $\epsilon$ has mean zero and variance $\sigma^2$. The regressors $X_1,
\dots, X_p$ might be the original predictors, or could be transformations and
combinations of them, such as interactions or polynomials. The assumptions on
the distribution of $\epsilon$ are used to obtain the variance of $\hat \beta$
and hence are important for inference, while the assumption of a linear
relationship determines whether our mean function is accurate.

For these examples, we'll consider a simple multivariate setting where the
population relationship is nonlinear and we misspecify the model:

```{r}
nonlinear_pop <- population(
  x1 = predictor("runif", min = 1, max = 8),
  x2 = predictor("runif", min = 4, max = 12),
  y = response(0.7 + 0.8 * x1**2 + 1.2 * x2,
               family = gaussian(), error_scale = 4.0)
)

nonlinear_data <- sample_x(nonlinear_pop, n = 100) |>
  sample_y()

fit <- lm(y ~ x1 + x2, data = nonlinear_data)
```

We'll use `broom::augment()` to get diagnostic information from the fit in a
standardized data frame, making it easy to use ggplot2 to produce different
diagnostic plots.

## Residual plots

Residual plots can detect misspecification of the mean function. When we plot
the residuals against any linear combination of the regressors, they should have
mean zero and constant variance. If they do not, the model may be incorrect.

One such linear combination is the fitted values $\hat Y$. We can obtain the
residuals and fitted values from `broom::augment()`:

```{r}
augment(fit) |>
  ggplot(aes(x = .fitted, y = .resid)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  labs(x = "Fitted value", y = "Residual")
```

There is a suspicious trend here, but it is hard to tell what specifically is
wrong from the model from this. It would be more helpful to know which predictor
is modeled incorrectly.

To plot residuals versus the regressors, the regressinator provides
`augment_longer()`, which is like `augment()` but converts the data to long form
with one row per predictor per observation, making it easy to facet the
residuals:

```{r}
augment_longer(fit) |>
  ggplot(aes(x = .predictor_value, y = .resid)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  facet_wrap(vars(.predictor_name), scales = "free_x") +
  labs(x = "Predictor", y = "Residual")
```

The trend in the residuals against `x1` makes it clear that something is wrong
with our specification of `x1` in the model, which is correct: we modeled it as
linear when it should be quadratic.

Detecting misspecification is a matter of judgment, as the residuals are random
and trends can appear even when the model is well-specified. Using
`model_lineup()`, we can compare the true residual plots to several where the
model is correctly specified. Each row gives the plots for one simulation, and
one of the fives rows (at random) is the true residual plots:

```{r, fig.height=8}
model_lineup(fit, fn = augment_longer, n = 5) |>
  ggplot(aes(x = .predictor_value, y = .resid)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  facet_grid(rows = vars(.sample), cols = vars(.predictor_name),
             scales = "free_x") +
  labs(x = "Predictor", y = "Residual")
```

This gives a sense of the variation to be expected when the model is
well-specified. It should still be easy to spot the row containing the plots for
our misspecified model.

## Partial residual plots

The `partial_residuals()` function fetches partial residuals in a convenient
data frame format. Partial residuals are defined in terms of the original
predictors, not the regressors; we can think of a partial residual plot for a
particular predictor as showing the relationship between that predictor and the
response, after "adjusting for" the other predictors according to our fitted
model. See the function documentation for references on the use and
interpretation of partial residuals.

Here the black line gives the fitted predictor effects (i.e. the model estimate
of the relationship), while the blue line smooths the partial residuals. We can
see that for `x1`, the blue line deviates systematically from the black line:

```{r}
partial_residuals(fit) |>
  ggplot(aes(x = .predictor_value, y = .partial_resid)) +
  geom_point() + # partial residuals
  geom_smooth(se = FALSE) + # smoothed residuals
  geom_line(aes(x = .predictor_value, y = .predictor_effect)) + # effects
  facet_wrap(vars(.predictor_name), scales = "free") +
  labs(x = "Predictor", y = "Partial residual")
```

The shape of the blue line approximates the shape of the true relationship
between `x1` and the response (provided the rest of the model is
well-specified!), so we can use its shape to determine how to change our model.

We can again use `model_lineup()` to see how these compare to the partial
residuals when the model is correctly specified:

```{r, fig.height=8}
model_lineup(fit, partial_residuals, n = 5) |>
  ggplot(aes(x = .predictor_value, y = .partial_resid)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  geom_line(aes(x = .predictor_value, y = .predictor_effect)) +
  facet_grid(rows = vars(.sample), cols = vars(.predictor_name),
             scales = "free") +
  labs(x = "Predictor", y = "Partial residual")
```

In the plots where the model is correctly specified, the blue and black lines
coincide, making it easy to spot the misspecified model.

## Cook's distances

The Cook's distance for an observation represents how much the model fitted
values would change if that observation were removed, scaled by the model's mean
squared error. A Cook's distance of 1 is often considered a cutoff for a highly
influential observation.

```{r}
augment(fit) |>
  ggplot(aes(x = seq_along(.cooksd), y = .cooksd)) +
  geom_col() +
  labs(x = "Row index", y = "Cook's distance")
```

Note that the Cook's distance measures changes in fitted values. If several
regressors are collinear, a small change in an observation may change $\hat
\beta$ dramatically but not change the fitted values much. (It can also be
interpreted as the Mahalanobis distance between the fitted $\hat \beta$ with and
without each observation, where the Mahalanobis distance takes into account the
variance of $\hat \beta$; collinear regressors will tend to have high variance
in their parameter estimates, so while dropping a covariate may change their
entries in $\hat \beta$, this will not cause a great increase in the Mahalanobis
distance.)

## Residual Q-Q plots

To see the distribution of the standardized residuals, and compare it to a
normal distribution:

```{r}
augment(fit) |>
  ggplot(aes(sample = .std.resid)) +
  geom_qq() +
  geom_qq_line() +
  labs(title = "Normal Q-Q plot of standardized residuals",
       x = "Theoretical quantiles", y = "Observed quantiles")
```

It is difficult for novices to judge normality from a Q-Q plot, so a lineup can
be helpful:

```{r, fig.height=8}
model_lineup(fit) |>
  ggplot(aes(sample = .std.resid)) +
  geom_qq() +
  geom_qq_line() +
  facet_wrap(vars(.sample)) +
  labs(title = "Normal Q-Q plot of standardized residuals",
       x = "Theoretical quantiles", y = "Observed quantiles")
```

The true Q-Q plot does not stand out here, so we have little evidence for a
systematically non-normal residuals.
